%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% File    : dual_iteration.m                                              %
%                                                                         %
% Author  : Tobias Holicki                                                %
% Version : 08                                                            %
% Date    : 06.03.2020                                                    %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% This function implements the dual iteration for robust output-feedback
% controller synthesis as explained in [1].
%
% For a given uncertain system (usys) with linear fractional representation 
% involving an LTI system (sys)
%   dot x = A x +   Bw +  B2d +  B3u        
%       z = C x +   Dw + D12d + D13u
%       e = C2x + D21w + D22d + D23u
%       y = C3x + D31w + D32d + D33u
% and an uncertainty (del)
%       w = Del z,
% this function aims to design a robust dynamic output-feedback controller
%   dot xk = Ak xk + Bk y
%        u = Ck xk + Dk y 
% such that the H_infty norm of the closed-loop system of the channel 
% d -> e is as small as possible for all uncertainties Del. 
%
% We assume that the uncertainty Del is block diagonal and involves 
% multiple real repeated and/or dynamic (full/repeated) uncertainties.
% These uncertainties are captured via static IQCs and D and DG scalings.
% In particular, the uncertainties can even be time-varying.
%
% References:
% [1] T. Holicki and C.W. Scherer, Revisiting the Dual Iteration for Static
%     and Robust Output-Feedback Synthesis, Int. J. Rob. Nonlin., 31(11),
%     p. 5427-5459, 2021, https://doi.org/10.1002/rnc.5547
%    
% ----- Syntax ---------------------------------------------------------
% [K, ga, p] = dual_iteration(usys, mea, act)
% [K, ga, p] = dual_iteration(sys, del, mea, act)
% [K, ga, p] = dual_iteration(___, opt)
% ----- Input ---------------------------------------------------------- 
% sys          - A linear system as given above
% del          - A block diagonal collection of uncertainties. Currently
%                supported are those generated by 'ureal' and 'ultidyn'
% usys         - An uncertain system in the 'uss' format. It is related to
%                to two inputs above by usys = lft(del, sys)
% mea          - Numver of measurements, i.e., number of components in y
% act          - Number of actuators, i.e., number of components in u
% opt          - Struct for several options
% opt.disp     - Display some stuff
% opt.num_ite  - Number of iterations (primal and dual step!)
% opt.opt_gs   - Solver options for the initial gain-scheduling desgin
% opt.opt_of   - Solver options during the iteration
% opt.bou_gs   - Bound for resolving the gain-scheduling problem in order
%                to obtain a better conditioned initial gain
% opt.bou_of   - Bound for resolving the design problems during the 
%                iteration in order to obtain better conditioned matrices
% opt.fac_fi   - The computed lower bound is multiplied by this factor and
%                the result is used as initial guess for the achievable 
%                upper bound
% ----- Output ---------------------------------------------------------
%   K        - Robust output-feedback controller
%   ga       - Computed upper bound on the worst-case closed-loop H_infty
%              norm
%   p        - Struct with lots of stuff computed during the iteration such
%              as
%   p.ga_gs  - Computed lower bound from the gain-scheduling design problem
%   p.F      - Computed gain from the robust full-information problem
%   p.E      - Computed gain from the robust full-actuation problem
%   p.ga_ofF - Computed upper bound from the last design with given F
%   p.ga_ofE - Computed upper bound from the last design with given E
%  
function [K, ga, p] = dual_iteration(sys, varargin)
%% Handle input with some sanity checks

lv = length(varargin);
if lv <= 1 || lv >= 5
   error('Wrong number of input arguments') 
end

% If an LFR is explicitely provided
if isa(varargin{1}, 'uss') || isa(varargin{1}, 'umat') 
    if ~isa(sys, 'ss')
       error('First input should be a state space model') 
    end
    % Uncertain system data
    [tmp, ~, p.blk, p.del] = lftdata(varargin{1});
    [nw, nz] = size(varargin{1});
    p.sys    = lft(tmp, sys, nz, nw);
    
    % Get the block diagonal (normalized and renamed) uncertainties
    p.del = blkdiag(p.del{:}); 
    
    % Change names in p.blk (this containes info on the block dimensions)
    for l = 1 : length(p.blk)
       p.blk(l).Name = [p.blk(l).Name, 'Normalized']; 
    end
    
    
    if ~isnumeric(varargin{2}) || ~isnumeric(varargin{3})
        error('Second and third input should be positive integers')
    end
    sft = 1; % A shift for reading the remaining inputs
    
% No LFR provided and matlab generates an LFR via lftdata. The generated
% size might not be optimal.
elseif isnumeric(varargin{1}) 
    if ~isa(sys, 'uss') && ~isa(sys, 'genss') 
        error('First input should be an uncertain state space model')
    end
    % Uncertain system data. lftdata includes a normalization of the
    % uncertainty, but fields like "range" or "NominalValue" are not 
    % normalized in the second output for some reason. In the fourth this
    % is the case, but the uncertainties are renamed...
    [p.sys, ~, p.blk, p.del] = lftdata(sys);

    % Get the block diagonal (normalized and renamed) uncertainties
    p.del = blkdiag(p.del{:}); 

    % Change names in p.blk (this containes info on the block dimensions)
    for l = 1 : length(p.blk)
       p.blk(l).Name = [p.blk(l).Name, 'Normalized']; 
    end
    
    if ~isnumeric(varargin{2})
        error('Second input should be a positive integer')
    end
    sft = 0; % A shift for reading the remaining inputs
else
   error('Check the second input please') 
end

% User provided options
if lv == 3+sft
    opt = varargin{3+sft};
else
    opt = [];
end

%% Some default options

% Override display function of no display is desired
if ~isfield(opt, 'disp') || opt.disp == 0
    displ = @(x) 0; 
else
    displ = @(x) disp(x);
end

% Number of iterations
opt = ifnotisfield(opt, 'num_ite', 5);

% Solver options for GS design, initial FI design and main loop
opt = ifnotisfield(opt, 'opt_gs', [0, 200, 1e6, 50, 1]); 
opt = ifnotisfield(opt, 'opt_of', [0, 200, 1e6, 50, 1]); 

% Safety bound on the computed optimal performance (in %) in order to work
% with slightly better conditioned matrices
opt = ifnotisfield(opt, 'bou_gs',  1.1); % GS and initial FI design
opt = ifnotisfield(opt, 'bou_of', 1.03); % Main loop

% Factor for initial FI heuristic
opt = ifnotisfield(opt, 'fac_fi', 2); 


%% Determine all relevant (I/O) Dimensions

la = size(p.sys.a, 1); % Number of system states
lu = length(p.blk);    % Number of uncertainty blocks
for l = 1 : lu
   bd(l, :) = p.blk(l).Size * p.blk(l).Occurrences;
end
uoi      = sum(bd, 1);  % Total number of uncertainty outputs and inputs
suoi     = sum(uoi);    % Sum of the above
[so, si] = size(p.sys); % Total number of system outputs and inputs

mea = varargin{1+sft}; % Number of measurements
act = varargin{2+sft}; % Number of actuators
inp = [bd(:, 1); si-uoi(1)-act; act]; % Input partition
out = [bd(:, 2); so-uoi(2)-mea; mea]; % Output partition
dis = inp(end-1);    % Dimension of generalized disturbance
err = out(end-1);    % Dimension of error signal

% Modifications for gain-scheduled design
p.blke = p.blk;
for l = 1 : lu
   % Occurrences are doubled if scheduled components are involved
   if strcmp(p.blk(l).Type, 'sreal') || strcmp(p.blk(l).Type, 'sltidyn')
       p.blke(l).Occurrences = 2 * p.blke(l).Occurrences;
   end
   bd(l, :) = p.blke(l).Size * p.blke(l).Occurrences;
end
inpe = [bd(:, 1); si-uoi(1)-act; act]; % Input partition
oute = [bd(:, 2); so-uoi(2)-mea; mea]; % Output partition

%% Some common preparations

% Primal and dual system outer factors
[OX, OY] = outerfactor(p.sys, inp, out);

% Transformation to standard scalings
[Fp, Fd] = trafo_ns2s(p.del,  p.blk);
[Fpe, ~] = trafo_ns2s(p.del, p.blke);

% Update outer factors   
OX = blkdiag(eye(2*la), Fp, eye(err + dis)) * OX;
OY = blkdiag(eye(2*la), Fd, eye(err + dis)) * OY;

% Splitting for directly optimizing over ga
OY1 = OY(1:end-dis, :); 
OY2 = OY(end-dis+1:end, :);

% Handle continuous- and discrete-time cases
if isct(p.sys)
    stabblk = @(X) blkodiag(X, X);
else
    stabblk = @(X) blkdiag(X, -X);
end

%% Compute lower bound obtained from the gain-scheduling design criteria

% Get performance lower bound
p = design_gs(p, opt);

% Display lower bound
displ(['The computed lower bound is ', num2str(p.ga_gs)]);

%% Design an initial robust static full information controller

p = design_fi_heuristic(p, opt, p.ga_gs*opt.fac_fi);
% Display the distance of the multipliers appearing in the design above
displ(['The push resulted in the distance alpha = ', num2str(p.al)]);

% Initialization of initial guesses
p.ga_ofE = p.ga_gs*opt.fac_fi;

try
    p = design_ofF(p, opt);
catch ME
    error(['I did not find a suitable initial full-information gain ', ...
           'try to increase opt.fact_fi']);
    % More rigorously, one should probably use another dual iteration to
    % find a robustly stabilizing gain...
end

%% Iterate a bit

for i = 1 : opt.num_ite
    
    displ(['gamma(', num2str(2*(i-1)+1), ') = ', num2str(p.ga_ofF)]);
    
    p = design_ofE(p, opt);

    displ(['gamma(', num2str(2*i), ') = ', num2str(p.ga_ofE)]);
    
    p = design_ofF(p, opt);
end

%% Design a robust output-feedback controller

% Display upper bound
displ(['The computed upper bound is ', num2str(p.ga_ofF)]);

% Outputs
ga = p.ga_ofF;

% We allow for nonzero D33 terms and might have to adjust the controller
% essentially as shown, e.g., in p. 313 of
% [K. Zhou and J. Doyle, Robust and optimal control, 1996]
D33 = p.sys.d(end-mea+1:end, end-act+1:end);
if norm(D33) < 1e-8
    K = p.con;
else
    %K = lft([zeros(act, mea), eye(act); eye(mea), -D33], p.con);
    K = lft(p.con, [-D33, eye(mea); eye(act), zeros(act, mea)], mea, act);
end





%% *********************** Main Functions *********************************

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Function : design_gs.m                                                  %
%                                                                         %
% Author   : Tobias Holicki                                               %
% Version  : 03                                                           %
% Date     : 06.03.2020                                                   %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% This function implements synthesis criteria for designing a
% gain-scheduled output-feedback controller via LMIs.
%
% ----- Input ---------------------------------------------------------- 
%   p, opt  - See above
% ----- Output ---------------------------------------------------------
%   p       - Struct as before and
%   p.ga_gs - Upper bound on closed-loop energy gain
%  
function p = design_gs(p, opt)        
    %% Define variables

    setlmis([]);
    
    % *Parametric variables*
    [ga, ~, sga] = lmivar(1, [1, 1]);  % Performance level gamma
    [ Y, ~,  sY] = lmivar(1, [la, 1]); % Certificate Y of dual LMI
    [ X, ~,  sX] = lmivar(1, [la, 1]); % Certificate X of primal LMI
    
    % Multiplier related variables
    [Pp, Pd, Mp, Md] = multiplier_handling('lmivar', p.blk);
    
    % *Inner terms*
    IX  = lmivar(3, blkdiag(stabblk(sX), Pp, ...
                            zeros(err), -sga * eye(dis)));   
    IXr = blkdiag(zeros(2*la+suoi), eye(err), zeros(dis));
    IY  = lmivar(3, blkdiag(stabblk(sY), Pd, zeros(err)));
    IYr = blkdiag(zeros(2*la+suoi), eye(err));
    
    %% Constraints

    % *Primal LMI with X*
    k = newlmi;
    lmiterm([k, 1, 1, IX], OX', OX);
    lmiterm([k, 1, 1,  0], OX' * IXr * OX);
    
    % *Dual LMI with Y (and Schur complement applied)*
    k = newlmi;
    lmiterm([-k, 1, 1, IY], OY1', OY1);
    lmiterm([-k, 1, 1,  0], OY1' * IYr * OY1);
    lmiterm([-k, 2, 1,  0], OY2);
    lmiterm([-k, 2, 2, ga], 1, 1);
    
    % *Coupling*
    k = newlmi;
    lmiterm([-k, 1, 1, Y], 1, 1);
    lmiterm([-k, 1, 2, 0], eye(la));
    lmiterm([-k, 2, 2, X], 1, 1);  

    % *Uncertainty Multiplier*
    multiplier_handling('lmiterm', p.blk, Mp, Md, p.del);

    %% Solve problem

    lmis = getlmis;
    ndec = decnbr(lmis) - 1;
    
    [gao, xfeas] = mincx(lmis, [1, zeros(1, ndec)], opt.opt_gs);
    
    % Get optimal upper bound
    p.ga_gs = sqrt(gao);

    % Resolve LMIs with a lower bound on performance
    if opt.bou_gs ~= 1
        setlmis(lmis)

        k = newlmi;
        lmiterm([-k, 1, 1, ga], 1, 1);
        lmiterm([ k, 1, 1,  0], gao*opt.bou_gs^2);

        lmis = getlmis;
        [~, xfeas] = mincx(lmis, [1, zeros(1, ndec)], opt.opt_gs);
    end

    % Save relevant variables for potential speedup
    p.X  = dec2mat(lmis, xfeas,  X);
    p.Y  = dec2mat(lmis, xfeas,  Y);
    [p.Mp, p.Md] = dec2cell(lmis, xfeas, Mp, Md);
end



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Function : design_fi_heuristic.m                                        %
%                                                                         %
% Author   : Tobias Holicki                                               %
% Version  : 03                                                           %
% Date     : 06.03.2020                                                   %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% This function implements synthesis criteria for designing a
% gain-scheduled output-feedback controller via LMIs together with a
% heuristic to push the multipliers and their inverses close to each other.
%
% ----- Input ---------------------------------------------------------- 
%   p, opt - See above
%   ga     - Some performance level
% ----- Output ---------------------------------------------------------
%   p      - Struct as before and
%   p.F    - Full-information gain
%   p.al   - Push parameter
%  
function p = design_fi_heuristic(p, opt, ga)    
    %% Define variables

    setlmis([]);
    
    % *Parametric variables*
    [al, ~,  ~] = lmivar(1, [1, 1]);  % Push parameter
    [ Y, ~, sY] = lmivar(1, [la, 1]); % Certificate Y of dual LMI
    [ X, ~, sX] = lmivar(1, [la, 1]); % Certificate X of primal LMI
    
    % Multiplier related variables
    [Pp, Pd, Mp, Md] = multiplier_handling('lmivar', p.blk);
    
    % *Inner terms*
    IX  = lmivar(3, blkdiag(stabblk(sX), Pp, ...
                            zeros(err+dis)));   
    IXr = blkdiag(zeros(2*la+suoi), eye(err), -ga^2*eye(dis));
    IY  = lmivar(3, blkdiag(stabblk(sY), Pd, ...
                            zeros(err+dis)));
    IYr = blkdiag(zeros(2*la+suoi), eye(err), -ga^(-2)*eye(dis));

    %% Constraints

    % *Primal LMI with X*
    k = newlmi;
    lmiterm([k, 1, 1, IX], OX', OX);
    lmiterm([k, 1, 1,  0], OX' * IXr * OX);
    
    % *Dual LMI with Y (and Schur complement applied)*
    k = newlmi;
    lmiterm([-k, 1, 1, IY], OY', OY);
    lmiterm([-k, 1, 1,  0], OY' * IYr * OY);
    
    % *Coupling*
    k = newlmi;
    lmiterm([-k, 1, 1, Y], 1, 1);
    lmiterm([-k, 1, 2, 0], eye(la));
    lmiterm([-k, 2, 2, X], 1, 1);  

    % *Uncertainty Multiplier*
    multiplier_handling('lmiterm', p.blk, Mp, Md, p.del);
    
    % *Push heuristic*
    for ll = 1 : lu
        tpe = p.blk(ll).Type;
        if strcmp(tpe, 'ultidyn')
           oc = p.blk(ll).Occurrences;
           ee = eye(oc);
           k  = newlmi;
           lmiterm([-k, 1, 1, al], 1, 1);
           for ii = 1 : oc
               lmiterm([k, 1, 1, Mp{ll}], ee(:, ii)', ee(:, ii), 's');
               lmiterm([k, 1, 1, Md{ll}], ee(:, ii)', ee(:, ii), 's');
           end 
        elseif strcmp(tpe, 'ureal') || strcmp(tpe, 'uconvexhull')
           oc = size(Mp{ll}, 1);
           ee = eye(oc);
           [Dp, ~, ~] = lmivar(1, [oc, 1]);
           [Dd, ~, ~] = lmivar(1, [oc, 1]);
           k = newlmi;
           lmiterm([-k, 1, 1,     Dp], 1, 1);
           lmiterm([-k, 2, 1, Mp{ll}], 1, 1);
           lmiterm([-k, 2, 2,      0], ee);
           k = newlmi;
           lmiterm([-k, 1, 1,     Dd], 1, 1);
           lmiterm([-k, 1, 2, Md{ll}], 1, 1);
           lmiterm([-k, 2, 2,      0], ee);
           k  = newlmi;
           lmiterm([-k, 1, 1, al], 1, 1);
           for ii = 1 : oc
               lmiterm([k, 1, 1, Dp], ee(:, ii)', ee(:, ii), 's');
               lmiterm([k, 1, 1, Dd], ee(:, ii)', ee(:, ii), 's');
           end      
        end
    end
       
    %% Solve problem

    lmis = getlmis;
    ndec = decnbr(lmis) - 1;
    
    % Initial guess
    [Pp, Pd, Mi] = multiplier_handling('eval', p.blk, p.Mp, p.Md);
    
    IXi = blkdiag(stabblk(p.X), Pp, zeros(err+dis));
    IYi = blkdiag(stabblk(p.Y), Pd, zeros(err+dis));

    xinit = mat2dec(lmis, 1e6, p.Y, p.X, Mi{:}, IXi, IYi);
    
    [alo, xfeas] = mincx(lmis, [1, zeros(1, ndec)], opt.opt_gs, xinit);

    % Resolve LMIs with a lower bound on performance
    if opt.bou_gs ~= 1
        setlmis(lmis)

        k = newlmi;
        lmiterm([-k, 1, 1, al], 1, 1);
        lmiterm([ k, 1, 1,  0], alo*opt.bou_gs^2);

        lmis = getlmis;
        [alo, xfeas] = mincx(lmis, [1, zeros(1, ndec)], opt.opt_gs, xinit);
    end

    p.al = alo;

    % Save relevant variables for potential speedup
    p.X  = dec2mat(lmis, xfeas,  X);
    p.Y  = dec2mat(lmis, xfeas,  Y);
    [p.Mp, p.Md] = dec2cell(lmis, xfeas, Mp, Md);
    
    %% Reconstruct full-information controller

    p.Y  = inv(chol(p.Y));
    p.Y  = p.Y * p.Y';
    p.Md = cellfun(@inv, p.Md, 'un', 0); % Componentwise inverse
    [Pp, ~] = multiplier_handling('eval', p.blk, p.Md, p.Md, 'primal');
    
    % Middle matrix
    P = blkdiag(stabblk(p.Y), Fp' * Pp * Fp, ...
                eye(err), -ga^2*eye(dis));     
    P = middlematrix_permutation(P, inp(1:end-1), out(1:end-1), la);

    % U, V, W, ...
    [W, U, V] = WUV(ss2fiss(p.sys, inp, out), act, la+sum(inp)-act);

    % Apply elimination lemma
    p.F = elimi(P, U, V, W);
end


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% File     : design_ofF.m                                                 %
%                                                                         %
% Author   : Tobias Holicki                                               %
% Version  : 02                                                           %
% Date     : 06.03.2020                                                   %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% This function implements the primal synthesis LMIs of the dual iteration.
%
% ----- Input ---------------------------------------------------------- 
%   p, opt   - See above
%   p.F      - Given full-information gain
%   p.ga_ofE - Initial guess: Performance level
%   p.X      - Initial guess: Lyapunov certificate X
%   p.Y      - Initial guess: Lyapunov certificate Y
%   p.Mp     - Initial guess: Multiplier variables
% ----- Output ---------------------------------------------------------
%   p        - Struct as before with update on initial guesses and
%   p.E      - Full-actuation gain
%   p.con    - Robust output-feedback controller
%   p.ga_ofF - Upper bound on closed-loop energy gain
%
function p = design_ofF(p, opt)    
    %% Build outer factors
 
    % Second outer factor
    syF      = lft(ss2fiss(p.sys, inp, out), p.F);
    [OYF, ~] = outerfactor(syF, inp(1:end-1), out(1:end-1), 'ana');
    OYF      = blkdiag(eye(2*la), Fp, eye(dis + err)) * OYF;

    %% Define variables

    setlmis([]);
    
    % *Parametric variables*
    [ga, ~, sga] = lmivar(1, [1, 1]);  % Performance level gamma
    [ Y, ~,  sY] = lmivar(1, [la, 1]); % Certificate Y of prim. reduced LMI
    [ X, ~,  sX] = lmivar(1, [la, 1]); % Certificate X of primal LMI
    
    % Multiplier related variables
    [Pp, Pd, Mp, Md] = multiplier_handling('lmivar', p.blk, 'primal');

    % *Inner terms*
    IX  = lmivar(3, blkdiag(stabblk(sX), Pp, ...
                            zeros(err), -sga * eye(dis)));
    IXr = blkdiag(zeros(2*la+suoi), eye(err), zeros(dis));
    IY = lmivar(3, blkdiag(stabblk(sY), Pd, ...
                           zeros(err), -sga * eye(dis)));
    
    %% Constraints
  
    % *Primal LMI with X*
    k = newlmi;
    lmiterm([k, 1, 1, IX], OX', OX);
    lmiterm([k, 1, 1,  0], OX' * IXr * OX);
    
    % *Primal reduced LMI with Y and E*
    k = newlmi;   
    lmiterm([k, 1, 1, IY], OYF', OYF);
    lmiterm([k, 1, 1,  0], OYF' * IXr * OYF);
    
    % *Coupling*
    k = newlmi;
    lmiterm([-k, 1, 1, Y], 1, 1);
    lmiterm([-k, 1, 2, Y], 1, 1);
    lmiterm([-k, 2, 2, X], 1, 1);

    % *Uncertainty Multiplier*
    multiplier_handling('lmiterm', p.blk, Mp, Md, p.del, 'primal');
    
    %% Solve problem

    lmis = getlmis;
    ndec = decnbr(lmis) - 1;
    
    % Initial guesses
    gai = (p.ga_ofE*1.05)^2;
    [Pp, Pd, Mi] = multiplier_handling('eval', p.blk, p.Mp, p.Md,'primal');
    IXi = blkdiag(stabblk(p.X), Pp, zeros(err), -gai * eye(dis));
    IYi = blkdiag(stabblk(p.Y), Pd, zeros(err), -gai * eye(dis));

    xinit = mat2dec(lmis, gai, p.Y, p.X, Mi{:}, IXi, IYi);

    % Apply solver
    [gao, xfeas] = mincx(lmis, [1, zeros(1, ndec)], opt.opt_of, xinit);
    
    % Get optimal upper bound
    p.ga_ofF = sqrt(gao);
    
    % Resolve LMIs with lower bound on performance
    if opt.bou_of ~= 1
        setlmis(lmis)

        k = newlmi;
        lmiterm([-k, 1, 1, ga], 1, 1);
        lmiterm([ k, 1, 1,  0], gao*opt.bou_of^2);

        lmis = getlmis;
        [gao, xfeas] = mincx(lmis, [1, zeros(1, ndec)], opt.opt_of, xinit);
    end
    
    % Get relevant variables
    X  = dec2mat(lmis, xfeas, X);
    Y  = dec2mat(lmis, xfeas, Y); 
    [Mp, Md] = dec2cell(lmis, xfeas, Mp, Md);
    
    % Maybe speedup
    p.X  = inv(chol(X));
    p.X  = p.X * p.X';
    p.Y  = inv(chol(Y));
    p.Y  = p.Y * p.Y';
    
    p.Mp = cellfun(@inv, Mp, 'un', 0); % Componentwise inverse
    p.Md = cellfun(@inv, Md, 'un', 0); % Componentwise inverse

    [Pp, ~, ~, ~, Pe] = multiplier_handling('eval', p.blk, Mp, Md, ...
                                                                 'primal');
    
    
    %% Reconstruct robust (gain-scheduled) controller
    
    % Build extended certificate Xc (no inversion required here)
    U  = Y - X;
    Xc = [X, U; U, -U];

    % Middle matrix
    P = blkdiag(stabblk(Xc), Fpe' * Pe *Fpe, eye(err), -gao*eye(dis));
    P = middlematrix_permutation(P, inpe(1:end-1), oute(1:end-1), 2*la); 
        
    % U, V, W... appropriately sorting every channel...
    di = [0, (inpe(1:end-1)-inp(1:end-1))'];
    do = [0, (oute(1:end-1)-out(1:end-1))'];
    [W, U, V] = WUV(p.sys, act, mea, la, sum(di), sum(do));
    
    in = [2*la, inp(1:end-1)', di(di~=0)];
    ou = [2*la, out(1:end-1)', do(do~=0)];
    di(di~=0) = lu+2+(1 : sum(di>0));
    te = reshape([1:lu+2; di], 2*(lu+2), 1);
    te = te(te~=0);
    
    W = blkpermut(W, in, ou, te, te);
    V = blkpermut(V, in, ':', te, ':');
    U = blkpermut(U, ou, ':', te, ':');
    
    
    % Apply elimination lemma
    if isct(p.sys)
        p.con = mat2ss(elimi(P, U, V, W), la); 
    else
        [~, ~, ~, ~, Ts] = ssdata(p.sys);
        p.con = mat2ss(elimi(P, U, V, W), la, Ts);
    end
    
    
    %% Reconstruct full-actuation gain
    
    % Middle matrix
    P = blkdiag(stabblk(X), Fp' * Pp * Fp, eye(err), -gao*eye(dis));
    P = middlematrix_permutation(P, inp(1:end-1), out(1:end-1), la); 
    
    % U, V, W...
    [W, U, V] = WUV(ss2fass(p.sys, inp, out), la+sum(out)-mea, mea);

    % Apply elimination lemma
    p.E = elimi(P, U, V, W);
end



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% File     : design_ofE.m                                                 %
%                                                                         %
% Author   : Tobias Holicki                                               %
% Version  : 02                                                           %
% Date     : 06.03.2020                                                   %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% This function implements the dual synthesis LMIs of the dual iteration
% 
% ----- Input ---------------------------------------------------------- 
%   p, opt   - See above
%   p.E      - Given full-actuation gain
%   p.ga_ofF - Initial guess: Performance level
%   p.X      - Initial guess: Lyapunov certificate X
%   p.Y      - Initial guess: Lyapunov certificate Y
%   p.Md     - Initial guess: Multiplier variables
% ----- Output ---------------------------------------------------------
%   p        - Struct as before with update on initial guesses and
%   p.F      - Full-information gain
%   p.ga_ofE - Upper bound on closed-loop energy gain
%
function p = design_ofE(p, opt)
    %% Build outer factors and stuff

    % Second outer factor
    syE      = lft(ss2fass(p.sys, inp, out), p.E);
    [~, OXE] = outerfactor(syE, inp(1:end-1), out(1:end-1), 'ana');
    OXE      = blkdiag(eye(2*la), Fd, eye(err+dis)) * OXE;
    % Splitting for directly optimizing over ga
    OXE1 = OXE(1:end-dis, :);
    OXE2 = OXE(end-dis+1:end, :);
    
    %% Define variables

    setlmis([]);
    
    % *Parametric variables*
    [ga, ~,   ~] = lmivar(1, [1, 1]);  % Performance level gamma
    [ Y, ~,  sY] = lmivar(1, [la, 1]); % Certificate Y of dual LMI
    [ X, ~,  sX] = lmivar(1, [la, 1]); % Certificate X of primal LMI
    
    % Multiplier related variables
    [Pp, Pd, Mp, Md] = multiplier_handling('lmivar', p.blk, 'dual');
    
    % *Inner terms*
    IX  = lmivar(3, blkdiag(stabblk(sX), Pp, zeros(err)));   
    IXr = blkdiag(zeros(2*la+suoi), eye(err));
    IY  = lmivar(3, blkdiag(stabblk(sY), Pd, zeros(err)));
    
    %% Constraints

    % *Primal LMI with X (after Schur complement)*
    k = newlmi;
    lmiterm([-k, 1, 1, IX], OXE1', OXE1);
    lmiterm([-k, 1, 1,  0], OXE1' * IXr * OXE1);
    lmiterm([-k, 2, 1,  0], OXE2);
    lmiterm([-k, 2, 2, ga], 1, 1);
    
    % *Dual LMI with Y (after Schur complement)*
    k = newlmi;
    lmiterm([-k, 1, 1, IY], OY1', OY1);
    lmiterm([-k, 1, 1,  0], OY1' * IXr * OY1);
    lmiterm([-k, 2, 1,  0], OY2);
    lmiterm([-k, 2, 2, ga], 1, 1);
    
    % *Coupling*
    k = newlmi;
    lmiterm([-k, 1, 1, Y], 1, 1);
    lmiterm([-k, 1, 2, X], 1, 1);
    lmiterm([-k, 2, 2, X], 1, 1);  
    
    % *Uncertainty Multiplier*
    multiplier_handling('lmiterm', p.blk, Mp, Md, p.del, 'dual');

    %% Solve problem
    
    lmis = getlmis;
    ndec = decnbr(lmis) - 1;
    
    % Initial guesses
    gai     = (p.ga_ofF*1.05)^2;
    [Pp, Pd, Mi] = multiplier_handling('eval', p.blk, p.Mp, p.Md, 'dual');
    IXi     = blkdiag(stabblk(p.X), Pp, zeros(err)); 
    IYi     = blkdiag(stabblk(p.Y), Pd, zeros(err));
    xinit   = mat2dec(lmis, gai, p.Y, p.X, Mi{:}, IXi, IYi);
    
    % Apply solver
    [gao, xfeas] = mincx(lmis, [1, zeros(1, ndec)], opt.opt_of, xinit);
    
    % Get optimal upper bound
    p.ga_ofE = sqrt(gao);
    
    % Resolve LMIs with lower bound on performance
    if opt.bou_of ~= 1
        setlmis(lmis)

        k = newlmi;
        lmiterm([-k, 1, 1, ga], 1, 1);
        lmiterm([ k, 1, 1,  0], gao*opt.bou_of^2);

        lmis = getlmis;
        [gao, xfeas] = mincx(lmis, [1, zeros(1, ndec)], opt.opt_of, xinit);
    end
    
    % Get relevant variables
    Y  = dec2mat(lmis, xfeas, Y);
    X  = dec2mat(lmis, xfeas, X);
    [Mp, Md] = dec2cell(lmis, xfeas, Mp, Md);
    
    % Maybe speedup
    p.X = inv(chol(X));
    p.X = p.X * p.X';
    p.Y = inv(chol(Y));
    p.Y = p.Y * p.Y';

    p.Mp = cellfun(@inv, Mp, 'un', 0); % Componentwise inverse
    p.Md = cellfun(@inv, Md, 'un', 0); % Componentwise inverse

    [Pp, ~] = multiplier_handling('eval', p.blk, p.Md, p.Md, 'primal');

    %% Reconstruct full-information controller
        
    % Middle matrix
    P = blkdiag(stabblk(p.Y), Fp' * Pp * Fp, eye(err),-gao*eye(dis));
    P = middlematrix_permutation(P, inp(1:end-1), out(1:end-1), la);
    
    % U, V, W, ...
    [W, U, V] = WUV(ss2fiss(p.sys, inp, out), act, la+sum(inp)-act);
    
    % Apply elimination lemma
    p.F = elimi(P, U, V, W);    
end


end% of dual iteration






%% *********************** Auxilliary Functions ***************************


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Function: ifnotisfield.m                                                %
%                                                                         %
% Author  : Tobias Holicki                                                %
% Version : 01                                                            %
% Date    : 06.03.2020                                                    %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% This is just an abbreviation
function opt = ifnotisfield(opt, fieldname, value)  
  if ~isfield(opt, fieldname)
      opt.(fieldname) = value;
  end
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Function: dec2cell.m                                                    %
%                                                                         %
% Author  : Tobias Holicki                                                %
% Version : 01                                                            %
% Date    : 06.03.2020                                                    %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% This is a particular variant of dec2mat
%
function [Mp, Md] = dec2cell(lmis, xfeas, Mp, Md)
    lu = length(Mp);
    for l = 1 : lu
       if ~isempty(Mp{l}) && ~isempty(Md{l})
           Mp{l} = dec2mat(lmis, xfeas, Mp{l});
           Md{l} = dec2mat(lmis, xfeas, Md{l});
       elseif ~isempty(Mp{l}) &&  isempty(Md{l})
           Mp{l} = dec2mat(lmis, xfeas, Mp{l});
           Md{l} = Mp{l};
       elseif isempty(Mp{l}) && ~isempty(Md{l})
           Md{l} = dec2mat(lmis, xfeas, Md{l});
           Mp{l} = Md{l};
       end
    end
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Function: trafo_ns2s.m                                                  %
%                                                                         %
% Author  : Tobias Holicki                                                %
% Version : 02                                                            %
% Date    : 18.12.2020                                                    %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% This functions returns a transformation matrix that transform scaled 
% (nonstandard) scalings into standard ones. 
%
% For example if del is composed of a single repeated dynamic uncertainty, 
% i.e., del = d*I, whose norm is bouned by r, then we have 
%            [I; del]' * [r^2 M, 0; 0, -M] * [I; del] >= 0
% for M > 0 and this function would return Tp = [rI, 0; 0; I], since
%         Tp' * [M, 0; 0, -M] * Tp = [r^2 M, 0; 0, -M].
%
% If del is composed of a single real repeated uncertainty, i.e., 
% del = d*I, with d in [a, b], then we have 
%       [I; del]' * [-ab(M+M'), bM'+aM; ()', -(M+M')] * [I; del] >= 0
% for M +M'> 0 and this function would return Tp = [bI, -I; -aI; I], since
%      Tp' * [0, M'; M, 0] * Tp = [-ab(M+M'), bM'+aM; ()', -(M+M')].
% This is essentially a transformation from D/G to positive real scalings.
% 
% This function also generates the matrix Td appearing when transforming 
% the dual LMIs
%         [-del'; I]' * Td' * Pd * Td * [-del'; I] <= 0.
% 
% ----- Input ---------------------------------------------------------- 
%       del - uss struct containing properties of the uncertainties
%       blk - struct as returned by [~, ~, blk] = lftdata( ... ) containing
%             information on the size/type of the uncertainty blocks
% ----- Output ---------------------------------------------------------
%        Tp - Primal transformation matrix as above
%        Td - Dual transformation matrix as above
%
function [Tp, Td] = trafo_ns2s(del, blk)

lu = length(blk); % Number of uncertainties

% Initializations
Tp = cell(lu, 1);
Td = cell(lu, 1);

% Construction of the matrices
if lu == 1
    [Tp, Td] = multiplier_handling_individual('trafo', blk, del);
else
    for l = 1 : lu
        dell           = del.Uncertainty.(blk(l).Name);
        [Tp{l}, Td{l}] = multiplier_handling_individual('trafo', ...
                                                        blk(l), dell);
    end
    Tp = blkdiag(Tp{:});
    Td = blkdiag(Td{:});
end
end


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Function: multiplier_handling.m                                         %
%                                                                         %
% Author  : Tobias Holicki                                                %
% Version : 02                                                            %
% Date    : 18.12.2020                                                    %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% This function can handle the multipliers and their components in various
% ways. It is the blockwise version of 'multiplier_handling_individual'
% and has essentially the identical syntax.
%
function [Pp, Pd, Mp, Md, Pe] = multiplier_handling(mode, blk, varargin)

lv = length(varargin); % Number of additional inputs
lu = length(blk);      % Number of uncertainties

% Initializations
Pp = cell(lu, 1);
Pd = cell(lu, 1);
Mp = cell(lu, 1);
Md = cell(lu, 1);
Pe = cell(lu, 1);

% Introduce multiplier variables
if strcmp(mode, 'lmivar')%-------------------------------------------------    
    for l = 1 : lu
        [Pp{l}, Pd{l}, Mp{l}, Md{l}] = multiplier_handling_individual(...
                                                mode, blk(l), varargin{:});
    end% for  
    Pp = blkdiag(Pp{:});
    Pd = blkdiag(Pd{:});
% Formulate contraints on multiplier components    
elseif strcmp(mode, 'lmiterm')%--------------------------------------------
    Mp  = varargin{1};
    Md  = varargin{2};
    del = varargin{3};
    if lu == 1
        multiplier_handling_individual(mode, blk(1), Mp{1}, Md{1}, del, ...
                                                          varargin{4:end});
    else
        for l = 1 : lu
            dell = del.Uncertainty.(blk(l).Name);
            multiplier_handling_individual(mode, blk(l), Mp{l}, Md{l}, ...
                                                    dell, varargin{4:end});
        end% for
    end
elseif strcmp(mode, 'eval')  
    Mp = varargin{1};
    Md = varargin{2};
    for l = 1 : lu
        [Pp{l}, Pd{l}, Mp{l}, Md{l}, Pe{l}] = ....
                                         multiplier_handling_individual(...
                              mode, blk(l), Mp{l}, Md{l}, varargin{3:end});
    end% for
    % Generate output for initial guess
    Mp = [Mp, Md]';
    Mp = Mp(:);
    Mp = Mp(~cellfun(@isempty, Mp));
    % For the multiplier extension
    if lv == 3 && strcmp(varargin{3}, 'primal')
        for l = 1 : lu
            if isempty(Pe{l})
               Pe{l} = Pp{l}; 
            end
        end
        Pe = blkdiag(Pe{:});
    end
    Pp = blkdiag(Pp{:});
    Pd = blkdiag(Pd{:});
else
    error('First input should be the string lmivar, lmiterm or eval')   
end

end


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Function: multiplier_handling_individual.m                              %
%                                                                         %
% Author  : Tobias Holicki                                                %
% Version : 02                                                            %
% Date    : 18.12.2020                                                    %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% This function can handle the multipliers and their components in various
% ways.
%
% ----- Input ----------------------------------------------------------
%      mode - Either the string lmivar, lmiterm or eval
%       blk - struct as returned by [~, ~, blk] = lftdata( ... ) containing
%             information on the size/type of the uncertainty blocks
%  varargin - Additional input depending on the used mode:
%             trafo: varargin should be the uncertainty to read off its 
%                    properties such as range, gain bound, ...
%             lmivar: varargin should be empty or one of the strings 
%                     'primal' and 'dual'.
%             lmiterm: varargin{1} should be a cell containing the
%                      variables appearing in the primal multipliers. 
%                      varargin{2} should be a cell containing the
%                      variables appearing in the dual multipliers.
%                      varargin{3} should be empty or one of the strings 
%                     'primal' and 'dual'.
%             eval: essentially the same as for lmiterm.
% ----- Output ---------------------------------------------------------
%        Pp - Transformation matrix or primal multiplier
%        Pd - Transfomation matrix or dual multiplier
%        Mp - Variables in the primal multipliers
%        Md - Variables in the dual multipliers
%        Pe - Extended multipliers for gain-scheduling purposes (only in 
%             'eval' mode)
% 
function [Pp, Pd, Mp, Md, Pe] = multiplier_handling_individual(mode, ...
                                                             blk, varargin)

lv  = length(varargin);
oc  = blk.Occurrences;
uio = blk.Size * blk.Occurrences;
Pp  = [];
Pd  = [];
Mp  = [];
Md  = [];
Pe  = [];

% ****************** Real parametric uncertainty ******************
if strcmp(blk.Type, 'ureal')
    if strcmp(mode, 'trafo') %---------------------------------------------
        del = varargin{1};
        ab  = del.Range;  
        Pp  = kron([ab(2), -1; -ab(1), 1], eye(oc)); 
        Pd  = kron([1, ab(1); 1, ab(2)] / (ab(2) - ab(1)), eye(oc));
    elseif strcmp(mode, 'lmivar') %----------------------------------------
        if lv == 0 % Gain-scheduling
            [Mp, ~,  sMp] = lmivar(2, oc * [1, 1]); 
            [Md, ~,  sMd] = lmivar(2, oc * [1, 1]); 
            Pp = [zeros(oc), sMp'; sMp, zeros(oc)];
            Pd = [zeros(oc), sMd; sMd', zeros(oc)];
        elseif strcmp(varargin{1}, 'primal') % Primal design
            [Mp, ~,  sMp] = lmivar(2, oc * [1, 1]); 
            Pp = [zeros(oc), sMp'; sMp, zeros(oc)];
            Pd = Pp;
        elseif strcmp(varargin{1}, 'dual') % Dual design
            [Md, ~,  sMd] = lmivar(2, oc * [1, 1]); 
            Pd = [zeros(oc), sMd; sMd', zeros(oc)]; 
            Pp = Pd;
        end
    elseif strcmp(mode, 'lmiterm')%----------------------------------------
        Mp = varargin{1};
        Md = varargin{2};
        if lv == 3 % Gain-scheduling
            k = newlmi;
            lmiterm([-k, 1, 1, Mp], 1, 1, 's');
            k = newlmi;
            lmiterm([-k, 1, 1, Md], 1, 1, 's'); 
        elseif strcmp(varargin{4}, 'primal') % Primal design
            k = newlmi;
            lmiterm([-k, 1, 1, Mp], 1, 1, 's');
        elseif strcmp(varargin{4}, 'dual') % Dual design
            k = newlmi;
            lmiterm([-k, 1, 1, Md], 1, 1, 's'); 
        end   
    elseif strcmp(mode, 'eval')%-------------------------------------------
        Mp = varargin{1};
        Md = varargin{2};
        if lv == 2 % Gain-scheudling
            Pp = [zeros(oc), Mp'; Mp, zeros(oc)];
            Pd = [zeros(oc), Md; Md', zeros(oc)];
        elseif strcmp(varargin{3}, 'primal') % Primal design
            Pp = [zeros(oc), Mp'; Mp, zeros(oc)];
            Pd = Pp;
            Md = [];
        elseif strcmp(varargin{3}, 'dual') % Dual design
            Pd = [zeros(oc), Md; Md', zeros(oc)];
            Pp = Pd;
            Mp = [];
        end 
    end%-------------------------------------------------------------------
    
% ****************** Real scheduling parameter ******************
elseif strcmp(blk.Type, 'sreal')
    if strcmp(mode, 'trafo')%----------------------------------------------
        del = varargin{1};
        ab  = del.Range;  
        Pp  = kron([ab(2), -1; -ab(1), 1], eye(oc)); 
        Pd  = kron([1, ab(1); 1, ab(2)] / (ab(2) - ab(1)), eye(oc));
    elseif strcmp(mode, 'lmivar')%-----------------------------------------
        [Mp, ~,  sMp] = lmivar(2, oc * [1, 1]); 
        [Md, ~,  sMd] = lmivar(2, oc * [1, 1]); 
        if lv == 0 % Gain-scheduling
            Pp = [zeros(oc), sMp'; sMp, zeros(oc)];
            Pd = [zeros(oc), sMd; sMd', zeros(oc)];
        elseif strcmp(varargin{1}, 'primal') % Primal design
            Pp = [zeros(oc), sMp'; sMp, zeros(oc)];
            Pd = [zeros(oc), sMd'; sMd, zeros(oc)];
        elseif strcmp(varargin{1}, 'dual') % Dual design
            Pp = [zeros(oc), sMp; sMp', zeros(oc)]; 
            Pd = [zeros(oc), sMd; sMd', zeros(oc)]; 
        end
    elseif strcmp(mode, 'lmiterm')%----------------------------------------
        Mp = varargin{1};
        Md = varargin{2};
        k  = newlmi;
        lmiterm([-k, 1, 1, Mp], 1, 1, 's');
        k  = newlmi;
        lmiterm([-k, 1, 1, Md], 1, 1, 's');  
    elseif strcmp(mode, 'eval')%-------------------------------------------
        Mp = varargin{1};
        Md = varargin{2};
        if lv == 2 % Gain-scheudling
            Pp = [zeros(oc), Mp'; Mp, zeros(oc)];
            Pd = [zeros(oc), Md; Md', zeros(oc)];
        elseif strcmp(varargin{3}, 'primal') % Primal design
            Pp = [zeros(oc), Mp'; Mp, zeros(oc)];
            Pd = [zeros(oc), Md'; Md, zeros(oc)];
            Me = [Mp, Mp - Md; Mp + Md', Mp + Md'];
            Pe = [zeros(2*oc), Me'; Me, zeros(2*oc)];
        elseif strcmp(varargin{3}, 'dual') % Dual design
            Pd = [zeros(oc), Md; Md', zeros(oc)];
            Pp = [zeros(oc), Mp; Mp', zeros(oc)];
        end 
    end%-------------------------------------------------------------------
    
% ****************** Dynamic uncertainty ******************    
elseif strcmp(blk.Type, 'ultidyn')
    if strcmp(mode, 'trafo')%----------------------------------------------
       del = varargin{1};
       r   = del.Bound; 
       Pp  = blkdiag(r * eye(uio(2)), eye(uio(1)));
       Pd  = blkdiag(eye(uio(2)) / r, eye(uio(1))); 
    elseif strcmp(mode, 'lmivar')%-----------------------------------------
        if lv == 0 % Gain-scheduling
           [Mp, ~, sMp] = lmivar(1, [oc, 1]);
           [Md, ~, sMd] = lmivar(1, [oc, 1]);
           Pp = blkdiag(kron(sMp, eye(uio(2))), -kron(sMp, eye(uio(1))));
           Pd = blkdiag(kron(sMd, eye(uio(2))), -kron(sMd, eye(uio(1))));
        elseif strcmp(varargin{1}, 'primal') % Primal design
            [Mp, ~, sMp] = lmivar(1, [oc, 1]);
            Pp = blkdiag(kron(sMp, eye(uio(2))), -kron(sMp, eye(uio(1))));
            Pd = Pp;
        elseif strcmp(varargin{1}, 'dual') % Dual design
            [Md, ~, sMd] = lmivar(1, [oc, 1]);
            Pd = blkdiag(kron(sMd, eye(uio(2))), -kron(sMd, eye(uio(1))));   
            Pp = Pd;
        end
    elseif strcmp(mode, 'lmiterm')%----------------------------------------
        Mp = varargin{1};
        Md = varargin{2};
        if lv == 3 % Gain-scheudling
            k = newlmi;
            lmiterm([-k, 1, 1, Mp], 1, 1);
            lmiterm([-k, 1, 2,  0], eye(oc));
            lmiterm([-k, 2, 2, Md], 1, 1);
        elseif strcmp(varargin{4}, 'primal') % Primal design
            k = newlmi;
            lmiterm([-k, 1, 1, Mp], 1, 1);
        elseif strcmp(varargin{4}, 'dual') % Dual design
            k = newlmi;
            lmiterm([-k, 1, 1, Md], 1, 1);
        end 
    elseif strcmp(mode, 'eval')%-------------------------------------------
        Mp = varargin{1};
        Md = varargin{2};
        if lv == 2 % Gain-scheudling
            Pp = blkdiag(kron(Mp, eye(uio(2))), -kron(Mp, eye(uio(1))));
            Pd = blkdiag(kron(Md, eye(uio(2))), -kron(Md, eye(uio(1))));
        elseif strcmp(varargin{3}, 'primal') % Primal design
            Pp = blkdiag(kron(Mp, eye(uio(2))), -kron(Mp, eye(uio(1))));
            Pd = Pp;
            Md = [];
        elseif strcmp(varargin{3}, 'dual') % Dual design
            Pd = blkdiag(kron(Md, eye(uio(2))), -kron(Md, eye(uio(1))));
            Pp = Pd;
            Mp = [];
        end 
    end%-------------------------------------------------------------------

% ****************** Dynamic scheduling component ******************    
elseif strcmp(blk.Type, 'sltidyn')
     if strcmp(mode, 'trafo')%----------------------------------------------
       del = varargin{1};
       r   = del.Bound; 
       Pp  = blkdiag(r * eye(uio(2)), eye(uio(1)));
       Pd  = blkdiag(eye(uio(2)) / r, eye(uio(1))); 
    elseif strcmp(mode, 'lmivar')%-----------------------------------------
       [Mp, ~, sMp] = lmivar(1, [oc, 1]);
       [Md, ~, sMd] = lmivar(1, [oc, 1]);
       Pp = blkdiag(kron(sMp, eye(uio(2))), -kron(sMp, eye(uio(1))));
       Pd = blkdiag(kron(sMd, eye(uio(2))), -kron(sMd, eye(uio(1))));
    elseif strcmp(mode, 'lmiterm')%----------------------------------------
        Mp = varargin{1};
        Md = varargin{2};
        if lv == 3 % Gain-scheduling
            k = newlmi;
            lmiterm([-k, 1, 1, Mp], 1, 1);
            lmiterm([-k, 1, 2,  0], eye(oc));
            lmiterm([-k, 2, 2, Md], 1, 1);
        elseif strcmp(varargin{4}, 'primal') % Primal design
            k = newlmi;
            lmiterm([-k, 1, 1, Mp], 1, 1);
            lmiterm([-k, 1, 2, Md], 1, 1);
            lmiterm([-k, 2, 2, Md], 1, 1);
        elseif strcmp(varargin{4}, 'dual') % Dual design
            k = newlmi;
            lmiterm([-k, 1, 1, Mp], 1, 1);
            lmiterm([-k, 1, 2, Mp], 1, 1);
            lmiterm([-k, 2, 2, Md], 1, 1);
        end
    elseif strcmp(mode, 'eval')%-------------------------------------------
        Mp = varargin{1};
        Md = varargin{2}; 
        Pp = blkdiag(kron(Mp, eye(uio(2))), -kron(Mp, eye(uio(1))));
        Pd = blkdiag(kron(Md, eye(uio(2))), -kron(Md, eye(uio(1))));
        U  = Md - Mp;
        Me = [Mp, U; U, -U];
        Pe = blkdiag(kron(Me, eye(uio(2))), -kron(Me, eye(uio(1))));
    end%-------------------------------------------------------------------
    
% ****************** Uncertainty in a convex hull ******************    
elseif strcmp(blk.Type, 'uconvexhull')
    if strcmp(mode, 'trafo')%----------------------------------------------
       Pp  = eye(uio(1)+uio(2));
       Pd  = eye(uio(1)+uio(2)); 
    elseif strcmp(mode, 'lmivar')%-----------------------------------------
        if lv == 0 % Gain-scheduling
           [Mp, ~, sMp] = lmivar(1, [uio(1)+uio(2), 1]);
           [Md, ~, sMd] = lmivar(1, [uio(1)+uio(2), 1]);
           Pp = sMp;
           Pd = sMd;
        elseif strcmp(varargin{1}, 'primal') % Primal design
            [Mp, ~, sMp] = lmivar(1, [uio(1)+uio(2), 1]);
            Pp = sMp;
            Pd = Pp;
        elseif strcmp(varargin{1}, 'dual') % Dual design
            [Md, ~, sMd] = lmivar(1, [uio(1)+uio(2), 1]);
            Pd = sMd;   
            Pp = Pd;
        end
    elseif strcmp(mode, 'lmiterm')%----------------------------------------
        Mp  = varargin{1};
        Md  = varargin{2};
        del = varargin{3};
        Op = [zeros(size(del, 2), size(del, 1)); eye(size(del, 1))];
        Od = [eye(size(del, 2)); zeros(size(del))];
        if lv == 3 % Gain-scheudling
            k = newlmi;
            lmiterm([k, 1, 1, Mp], Op', Op);
            k = newlmi;
            lmiterm([-k, 1, 1,  Md], Od', Od);
        elseif strcmp(varargin{4}, 'primal') % Primal design
            k = newlmi;
            lmiterm([k, 1, 1, Mp], Op', Op);
        elseif strcmp(varargin{4}, 'dual') % Dual design
            k = newlmi;
            lmiterm([-k, 1, 1, Md], Od', Od);
        end 
        %del.Generators{1}
        %del.generators{2}
        for j = 1 : length(del.Generators)
            Op = [eye(size(del, 2)); del.Generators{j}];
            Od = [-del.Generators{j}'; eye(size(del, 1))];
            if lv == 3 % Gain-scheudling
                k = newlmi;
                lmiterm([-k, 1, 1, Mp], Op', Op);
                k = newlmi;
                lmiterm([k, 1, 1,  Md], Od', Od);
            elseif strcmp(varargin{4}, 'primal') % Primal design
                k = newlmi;
                lmiterm([-k, 1, 1, Mp], Op', Op);
            elseif strcmp(varargin{4}, 'dual') % Dual design
                k = newlmi;
                lmiterm([k, 1, 1, Md], Od', Od);
            end 
        end
    elseif strcmp(mode, 'eval')%-------------------------------------------
        Mp = varargin{1};
        Md = varargin{2};
        if lv == 2 % Gain-scheudling
            Pp = Mp;
            Pd = Md;
        elseif strcmp(varargin{3}, 'primal') % Primal design
            Pp = Mp;
            Pd = Pp;
            Md = [];
        elseif strcmp(varargin{3}, 'dual') % Dual design
            Pd = Md;
            Pp = Pd;
            Mp = [];
        end 
    end%-------------------------------------------------------------------
end

end

